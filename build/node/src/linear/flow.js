"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "flow", {
    enumerable: true,
    get: function() {
        return flow;
    }
});
const _function = /*#__PURE__*/ _interop_require_wildcard(require("@dashkite/joy/function"));
const _type = /*#__PURE__*/ _interop_require_wildcard(require("@dashkite/joy/type"));
const _generic = require("@dashkite/joy/generic");
const _containers = require("../containers");
const _async = /*#__PURE__*/ _interop_require_wildcard(require("../strict/async"));
const _helpers = /*#__PURE__*/ _interop_require_wildcard(require("./helpers"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
var _flow, debug, finished, flow;
flow = (0, _generic.generic)({
    name: "talos flow",
    default: function(...args) {
        throw new Error(`flow: input is malformed ${JSON.stringify(args)}`);
    }
});
(0, _generic.generic)(flow, _helpers.isFunctionArray, function(fx) {
    return _flow({}, fx);
});
(0, _generic.generic)(flow, _type.isObject, _helpers.isFunctionArray, function(options, fx) {
    return _flow(options, fx);
});
_flow = function(options, fx) {
    var drive, f, graph, step, talos;
    if (fx.length === 0) {
        if (options.debug === true) {
            console.log("[ flow ] empty function list, mapping to no-op");
        }
        return async function(x) {
            await Promise.resolve();
            return x;
        };
    }
    f = fx[0];
    graph = _containers.Graph.make(_helpers.expand(fx));
    talos = _containers.Talos.make();
    step = options.debug === true ? debug : _async.step;
    drive = _containers.Drive.make(graph, talos, step);
    return _function.arity(f.length, async function(...args) {
        await drive.update(...args);
        while(true){
            _helpers.check(talos);
            if (talos.halted) {
                return talos.context;
            }
            await drive.update();
        }
    });
};
finished = _helpers.finished("flow");
debug = async function(graph, talos, ...transforms) {
    var edge, name, vertex;
    vertex = _async.matchVertex(graph, talos);
    name = _helpers.nameVertex(vertex);
    if (finished(talos)) {
        return talos;
    }
    edge = await _async.matchEdge(vertex, talos, transforms);
    if (finished(talos)) {
        return talos;
    }
    console.log(`[ flow ] starting step ${name}`, talos.context);
    if (transforms.length > 0) {
        console.log("arguments", ...transforms);
    }
    await _async.run(edge, talos, transforms);
    if (finished(talos)) {
        return talos;
    }
    console.log(`[ flow ] finished step ${name}`);
    await _async.move(edge, talos, transforms);
    if (finished(talos)) {
        return talos;
    }
    return talos;
};
 //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL0BkYXNoa2l0ZS90YWxvcy9zcmMvbGluZWFyL2Zsb3cuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUEsS0FBQSxFQUFBLEtBQUEsRUFBQSxRQUFBLEVBQUE7O0FBQUEsT0FBTyxDQUFBLE1BQVAsTUFBQTs7QUFDQSxPQUFPLENBQUEsUUFBUCxNQUFBOztBQUNBLE9BQUE7RUFBUyxPQUFUO0NBQUEsTUFBQTs7QUFDQSxPQUFBO0VBQVMsS0FBVDtFQUFnQixLQUFoQjtFQUF1QixLQUF2QjtDQUFBLE1BQUE7O0FBQ0EsT0FBTyxDQUFBLFNBQVAsTUFBQTs7QUFDQSxPQUFPLENBQUEsS0FBUCxNQUFBOztBQUdBLElBQUEsR0FBTyxPQUFBLENBQ0w7RUFBQSxJQUFBLEVBQU0sWUFBTjtFQUNBLE9BQUEsRUFBUyxRQUFBLENBQUEsR0FBRSxJQUFGLENBQUE7SUFDUCxNQUFNLElBQUksS0FBSixDQUFVLENBQUEseUJBQUEsQ0FBQSxDQUE0QixJQUFJLENBQUMsU0FBTCxDQUFlLElBQWYsQ0FBNUIsQ0FBQSxDQUFWO0VBREM7QUFEVCxDQURLOztBQUtQLE9BQUEsQ0FBUSxJQUFSLEVBQWMsQ0FBQyxDQUFDLGVBQWhCLEVBQWlDLFFBQUEsQ0FBRSxFQUFGLENBQUE7U0FDL0IsS0FBQSxDQUFNLENBQUEsQ0FBTixFQUFVLEVBQVY7QUFEK0IsQ0FBakM7O0FBR0EsT0FBQSxDQUFRLElBQVIsRUFBYyxJQUFJLENBQUMsUUFBbkIsRUFBNkIsQ0FBQyxDQUFDLGVBQS9CLEVBQWdELFFBQUEsQ0FBRSxPQUFGLEVBQVcsRUFBWCxDQUFBO1NBQzlDLEtBQUEsQ0FBTSxPQUFOLEVBQWUsRUFBZjtBQUQ4QyxDQUFoRDs7QUFHQSxLQUFBLEdBQVEsUUFBQSxDQUFFLE9BQUYsRUFBVyxFQUFYLENBQUE7QUFDUixNQUFBLEtBQUEsRUFBQSxDQUFBLEVBQUEsS0FBQSxFQUFBLElBQUEsRUFBQTtFQUFFLElBQUcsRUFBRSxDQUFDLE1BQUgsS0FBYSxDQUFoQjtJQUNFLElBQUcsT0FBTyxDQUFDLEtBQVIsS0FBaUIsSUFBcEI7TUFDRSxPQUFPLENBQUMsR0FBUixDQUFZLGdEQUFaLEVBREY7O0FBRUEsV0FBTyxNQUFBLFFBQUEsQ0FBRSxDQUFGLENBQUE7TUFBUyxNQUFNLE9BQU8sQ0FBQyxPQUFSLENBQUE7YUFBb0I7SUFBbkMsRUFIVDs7RUFLQSxDQUFBLEdBQUksRUFBRSxDQUFFLENBQUY7RUFDTixLQUFBLEdBQVEsS0FBSyxDQUFDLElBQU4sQ0FBVyxDQUFDLENBQUMsTUFBRixDQUFTLEVBQVQsQ0FBWDtFQUNSLEtBQUEsR0FBUSxLQUFLLENBQUMsSUFBTixDQUFBO0VBQ1IsSUFBQSxHQUFVLE9BQU8sQ0FBQyxLQUFSLEtBQWlCLElBQXBCLEdBQThCLEtBQTlCLEdBQXlDLEtBQUssQ0FBQztFQUN0RCxLQUFBLEdBQVEsS0FBSyxDQUFDLElBQU4sQ0FBVyxLQUFYLEVBQWtCLEtBQWxCLEVBQXlCLElBQXpCO1NBRVIsRUFBRSxDQUFDLEtBQUgsQ0FBUyxDQUFDLENBQUMsTUFBWCxFQUFtQixNQUFBLFFBQUEsQ0FBQSxHQUFFLElBQUYsQ0FBQTtJQUNqQixNQUFNLEtBQUssQ0FBQyxNQUFOLENBQWEsR0FBQSxJQUFiO0FBQ04sV0FBQSxJQUFBO01BQ0UsQ0FBQyxDQUFDLEtBQUYsQ0FBUSxLQUFSO01BQ0EsSUFBd0IsS0FBSyxDQUFDLE1BQTlCO0FBQUEsZUFBTyxLQUFLLENBQUMsUUFBYjs7TUFDQSxNQUFNLEtBQUssQ0FBQyxNQUFOLENBQUE7SUFIUjtFQUZpQixDQUFuQjtBQVpNOztBQW9CUixRQUFBLEdBQVcsQ0FBQyxDQUFDLFFBQUYsQ0FBVyxNQUFYOztBQUVYLEtBQUEsR0FBUSxNQUFBLFFBQUEsQ0FBRSxLQUFGLEVBQVMsS0FBVCxFQUFBLEdBQWdCLFVBQWhCLENBQUE7QUFDUixNQUFBLElBQUEsRUFBQSxJQUFBLEVBQUE7RUFBRSxNQUFBLEdBQVMsS0FBSyxDQUFDLFdBQU4sQ0FBa0IsS0FBbEIsRUFBeUIsS0FBekI7RUFDVCxJQUFBLEdBQU8sQ0FBQyxDQUFDLFVBQUYsQ0FBYSxNQUFiO0VBQ1AsSUFBZ0IsUUFBQSxDQUFTLEtBQVQsQ0FBaEI7QUFBQSxXQUFPLE1BQVA7O0VBRUEsSUFBQSxHQUFPLENBQUEsTUFBTSxLQUFLLENBQUMsU0FBTixDQUFnQixNQUFoQixFQUF3QixLQUF4QixFQUErQixVQUEvQixDQUFOO0VBQ1AsSUFBZ0IsUUFBQSxDQUFTLEtBQVQsQ0FBaEI7QUFBQSxXQUFPLE1BQVA7O0VBRUEsT0FBTyxDQUFDLEdBQVIsQ0FBWSxDQUFBLHVCQUFBLENBQUEsQ0FBMkIsSUFBM0IsQ0FBQSxDQUFaLEVBQWdELEtBQUssQ0FBQyxPQUF0RDtFQUNBLElBQUcsVUFBVSxDQUFDLE1BQVgsR0FBb0IsQ0FBdkI7SUFDRSxPQUFPLENBQUMsR0FBUixDQUFZLFdBQVosRUFBeUIsR0FBQSxVQUF6QixFQURGOztFQUVBLE1BQU0sS0FBSyxDQUFDLEdBQU4sQ0FBVSxJQUFWLEVBQWdCLEtBQWhCLEVBQXVCLFVBQXZCO0VBQ04sSUFBZ0IsUUFBQSxDQUFTLEtBQVQsQ0FBaEI7QUFBQSxXQUFPLE1BQVA7O0VBQ0EsT0FBTyxDQUFDLEdBQVIsQ0FBWSxDQUFBLHVCQUFBLENBQUEsQ0FBMkIsSUFBM0IsQ0FBQSxDQUFaO0VBRUEsTUFBTSxLQUFLLENBQUMsSUFBTixDQUFXLElBQVgsRUFBaUIsS0FBakIsRUFBd0IsVUFBeEI7RUFDTixJQUFnQixRQUFBLENBQVMsS0FBVCxDQUFoQjtBQUFBLFdBQU8sTUFBUDs7U0FDQTtBQWpCTTs7QUFxQlIsT0FBQTtFQUNFLElBREYiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBGbiBmcm9tIFwiQGRhc2hraXRlL2pveS9mdW5jdGlvblwiXG5pbXBvcnQgKiBhcyBUeXBlIGZyb20gXCJAZGFzaGtpdGUvam95L3R5cGVcIlxuaW1wb3J0IHsgZ2VuZXJpYyB9IGZyb20gXCJAZGFzaGtpdGUvam95L2dlbmVyaWNcIlxuaW1wb3J0IHsgR3JhcGgsIFRhbG9zLCBEcml2ZSB9IGZyb20gXCIuLi9jb250YWluZXJzXCJcbmltcG9ydCAqIGFzIEFzeW5jIGZyb20gXCIuLi9zdHJpY3QvYXN5bmNcIlxuaW1wb3J0ICogYXMgaCBmcm9tIFwiLi9oZWxwZXJzXCJcblxuXG5mbG93ID0gZ2VuZXJpYyBcbiAgbmFtZTogXCJ0YWxvcyBmbG93XCJcbiAgZGVmYXVsdDogKCBhcmdzLi4uICkgLT4gXG4gICAgdGhyb3cgbmV3IEVycm9yIFwiZmxvdzogaW5wdXQgaXMgbWFsZm9ybWVkICN7SlNPTi5zdHJpbmdpZnkgYXJnc31cIlxuXG5nZW5lcmljIGZsb3csIGguaXNGdW5jdGlvbkFycmF5LCAoIGZ4ICkgLT5cbiAgX2Zsb3cge30sIGZ4XG5cbmdlbmVyaWMgZmxvdywgVHlwZS5pc09iamVjdCwgaC5pc0Z1bmN0aW9uQXJyYXksICggb3B0aW9ucywgZnggKSAtPlxuICBfZmxvdyBvcHRpb25zLCBmeFxuXG5fZmxvdyA9ICggb3B0aW9ucywgZnggKSAtPlxuICBpZiBmeC5sZW5ndGggPT0gMFxuICAgIGlmIG9wdGlvbnMuZGVidWcgPT0gdHJ1ZVxuICAgICAgY29uc29sZS5sb2cgXCJbIGZsb3cgXSBlbXB0eSBmdW5jdGlvbiBsaXN0LCBtYXBwaW5nIHRvIG5vLW9wXCJcbiAgICByZXR1cm4gKCB4ICkgLT4gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkgOyB4XG4gIFxuICBmID0gZnhbIDAgXVxuICBncmFwaCA9IEdyYXBoLm1ha2UgaC5leHBhbmQgZnhcbiAgdGFsb3MgPSBUYWxvcy5tYWtlKClcbiAgc3RlcCA9IGlmIG9wdGlvbnMuZGVidWcgPT0gdHJ1ZSB0aGVuIGRlYnVnIGVsc2UgQXN5bmMuc3RlcFxuICBkcml2ZSA9IERyaXZlLm1ha2UgZ3JhcGgsIHRhbG9zLCBzdGVwXG5cbiAgRm4uYXJpdHkgZi5sZW5ndGgsICggYXJncy4uLiApIC0+XG4gICAgYXdhaXQgZHJpdmUudXBkYXRlIGFyZ3MuLi5cbiAgICBsb29wXG4gICAgICBoLmNoZWNrIHRhbG9zXG4gICAgICByZXR1cm4gdGFsb3MuY29udGV4dCBpZiB0YWxvcy5oYWx0ZWRcbiAgICAgIGF3YWl0IGRyaXZlLnVwZGF0ZSgpXG5cblxuZmluaXNoZWQgPSBoLmZpbmlzaGVkIFwiZmxvd1wiXG5cbmRlYnVnID0gKCBncmFwaCwgdGFsb3MsIHRyYW5zZm9ybXMuLi4gKSAtPlxuICB2ZXJ0ZXggPSBBc3luYy5tYXRjaFZlcnRleCBncmFwaCwgdGFsb3NcbiAgbmFtZSA9IGgubmFtZVZlcnRleCB2ZXJ0ZXhcbiAgcmV0dXJuIHRhbG9zIGlmIGZpbmlzaGVkIHRhbG9zXG5cbiAgZWRnZSA9IGF3YWl0IEFzeW5jLm1hdGNoRWRnZSB2ZXJ0ZXgsIHRhbG9zLCB0cmFuc2Zvcm1zXG4gIHJldHVybiB0YWxvcyBpZiBmaW5pc2hlZCB0YWxvc1xuXG4gIGNvbnNvbGUubG9nIFwiWyBmbG93IF0gc3RhcnRpbmcgc3RlcCAjeyBuYW1lIH1cIiwgdGFsb3MuY29udGV4dFxuICBpZiB0cmFuc2Zvcm1zLmxlbmd0aCA+IDBcbiAgICBjb25zb2xlLmxvZyBcImFyZ3VtZW50c1wiLCB0cmFuc2Zvcm1zLi4uXG4gIGF3YWl0IEFzeW5jLnJ1biBlZGdlLCB0YWxvcywgdHJhbnNmb3Jtc1xuICByZXR1cm4gdGFsb3MgaWYgZmluaXNoZWQgdGFsb3NcbiAgY29uc29sZS5sb2cgXCJbIGZsb3cgXSBmaW5pc2hlZCBzdGVwICN7IG5hbWUgfVwiXG5cbiAgYXdhaXQgQXN5bmMubW92ZSBlZGdlLCB0YWxvcywgdHJhbnNmb3Jtc1xuICByZXR1cm4gdGFsb3MgaWYgZmluaXNoZWQgdGFsb3NcbiAgdGFsb3NcblxuXG5cbmV4cG9ydCB7XG4gIGZsb3dcbn0iXX0=
 //# sourceURL=/@dashkite/talos/src/linear/flow.coffee

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9AZGFzaGtpdGUvdGFsb3Mvc3JjL2xpbmVhci9mbG93LmNvZmZlZSIsIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBGbiBmcm9tIFwiQGRhc2hraXRlL2pveS9mdW5jdGlvblwiXG5pbXBvcnQgKiBhcyBUeXBlIGZyb20gXCJAZGFzaGtpdGUvam95L3R5cGVcIlxuaW1wb3J0IHsgZ2VuZXJpYyB9IGZyb20gXCJAZGFzaGtpdGUvam95L2dlbmVyaWNcIlxuaW1wb3J0IHsgR3JhcGgsIFRhbG9zLCBEcml2ZSB9IGZyb20gXCIuLi9jb250YWluZXJzXCJcbmltcG9ydCAqIGFzIEFzeW5jIGZyb20gXCIuLi9zdHJpY3QvYXN5bmNcIlxuaW1wb3J0ICogYXMgaCBmcm9tIFwiLi9oZWxwZXJzXCJcblxuXG5mbG93ID0gZ2VuZXJpYyBcbiAgbmFtZTogXCJ0YWxvcyBmbG93XCJcbiAgZGVmYXVsdDogKCBhcmdzLi4uICkgLT4gXG4gICAgdGhyb3cgbmV3IEVycm9yIFwiZmxvdzogaW5wdXQgaXMgbWFsZm9ybWVkICN7SlNPTi5zdHJpbmdpZnkgYXJnc31cIlxuXG5nZW5lcmljIGZsb3csIGguaXNGdW5jdGlvbkFycmF5LCAoIGZ4ICkgLT5cbiAgX2Zsb3cge30sIGZ4XG5cbmdlbmVyaWMgZmxvdywgVHlwZS5pc09iamVjdCwgaC5pc0Z1bmN0aW9uQXJyYXksICggb3B0aW9ucywgZnggKSAtPlxuICBfZmxvdyBvcHRpb25zLCBmeFxuXG5fZmxvdyA9ICggb3B0aW9ucywgZnggKSAtPlxuICBpZiBmeC5sZW5ndGggPT0gMFxuICAgIGlmIG9wdGlvbnMuZGVidWcgPT0gdHJ1ZVxuICAgICAgY29uc29sZS5sb2cgXCJbIGZsb3cgXSBlbXB0eSBmdW5jdGlvbiBsaXN0LCBtYXBwaW5nIHRvIG5vLW9wXCJcbiAgICByZXR1cm4gKCB4ICkgLT4gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkgOyB4XG4gIFxuICBmID0gZnhbIDAgXVxuICBncmFwaCA9IEdyYXBoLm1ha2UgaC5leHBhbmQgZnhcbiAgdGFsb3MgPSBUYWxvcy5tYWtlKClcbiAgc3RlcCA9IGlmIG9wdGlvbnMuZGVidWcgPT0gdHJ1ZSB0aGVuIGRlYnVnIGVsc2UgQXN5bmMuc3RlcFxuICBkcml2ZSA9IERyaXZlLm1ha2UgZ3JhcGgsIHRhbG9zLCBzdGVwXG5cbiAgRm4uYXJpdHkgZi5sZW5ndGgsICggYXJncy4uLiApIC0+XG4gICAgYXdhaXQgZHJpdmUudXBkYXRlIGFyZ3MuLi5cbiAgICBsb29wXG4gICAgICBoLmNoZWNrIHRhbG9zXG4gICAgICByZXR1cm4gdGFsb3MuY29udGV4dCBpZiB0YWxvcy5oYWx0ZWRcbiAgICAgIGF3YWl0IGRyaXZlLnVwZGF0ZSgpXG5cblxuZmluaXNoZWQgPSBoLmZpbmlzaGVkIFwiZmxvd1wiXG5cbmRlYnVnID0gKCBncmFwaCwgdGFsb3MsIHRyYW5zZm9ybXMuLi4gKSAtPlxuICB2ZXJ0ZXggPSBBc3luYy5tYXRjaFZlcnRleCBncmFwaCwgdGFsb3NcbiAgbmFtZSA9IGgubmFtZVZlcnRleCB2ZXJ0ZXhcbiAgcmV0dXJuIHRhbG9zIGlmIGZpbmlzaGVkIHRhbG9zXG5cbiAgZWRnZSA9IGF3YWl0IEFzeW5jLm1hdGNoRWRnZSB2ZXJ0ZXgsIHRhbG9zLCB0cmFuc2Zvcm1zXG4gIHJldHVybiB0YWxvcyBpZiBmaW5pc2hlZCB0YWxvc1xuXG4gIGNvbnNvbGUubG9nIFwiWyBmbG93IF0gc3RhcnRpbmcgc3RlcCAjeyBuYW1lIH1cIiwgdGFsb3MuY29udGV4dFxuICBpZiB0cmFuc2Zvcm1zLmxlbmd0aCA+IDBcbiAgICBjb25zb2xlLmxvZyBcImFyZ3VtZW50c1wiLCB0cmFuc2Zvcm1zLi4uXG4gIGF3YWl0IEFzeW5jLnJ1biBlZGdlLCB0YWxvcywgdHJhbnNmb3Jtc1xuICByZXR1cm4gdGFsb3MgaWYgZmluaXNoZWQgdGFsb3NcbiAgY29uc29sZS5sb2cgXCJbIGZsb3cgXSBmaW5pc2hlZCBzdGVwICN7IG5hbWUgfVwiXG5cbiAgYXdhaXQgQXN5bmMubW92ZSBlZGdlLCB0YWxvcywgdHJhbnNmb3Jtc1xuICByZXR1cm4gdGFsb3MgaWYgZmluaXNoZWQgdGFsb3NcbiAgdGFsb3NcblxuXG5cbmV4cG9ydCB7XG4gIGZsb3dcbn0iLG51bGxdLCJuYW1lcyI6WyJmbG93IiwiX2Zsb3ciLCJkZWJ1ZyIsImZpbmlzaGVkIiwiZ2VuZXJpYyIsIm5hbWUiLCJkZWZhdWx0IiwiYXJncyIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImgiLCJpc0Z1bmN0aW9uQXJyYXkiLCJmeCIsIlR5cGUiLCJpc09iamVjdCIsIm9wdGlvbnMiLCJkcml2ZSIsImYiLCJncmFwaCIsInN0ZXAiLCJ0YWxvcyIsImxlbmd0aCIsImNvbnNvbGUiLCJsb2ciLCJ4IiwiUHJvbWlzZSIsInJlc29sdmUiLCJHcmFwaCIsIm1ha2UiLCJleHBhbmQiLCJUYWxvcyIsIkFzeW5jIiwiRHJpdmUiLCJGbiIsImFyaXR5IiwidXBkYXRlIiwiY2hlY2siLCJoYWx0ZWQiLCJjb250ZXh0IiwidHJhbnNmb3JtcyIsImVkZ2UiLCJ2ZXJ0ZXgiLCJtYXRjaFZlcnRleCIsIm5hbWVWZXJ0ZXgiLCJtYXRjaEVkZ2UiLCJydW4iLCJtb3ZlIl0sIm1hcHBpbmdzIjoiOzs7OytCQStERUE7OztlQUFBQTs7O2tFQS9ERjs4REFDQTt5QkFDQTs0QkFDQTsrREFDQTtpRUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUxBLElBQUFDLE9BQUFDLE9BQUFDLFVBQUFIO0FBUUFBLE9BQU9JLElBQUFBLGdCQUFBLEVBQ0w7SUFBQUMsTUFBTTtJQUNOQyxTQUFTLFNBQUEsR0FBRUMsSUFBRjtRQUNQLE1BQU0sSUFBSUMsTUFBTSxDQUFBLHlCQUFBLEVBQTRCQyxLQUFLQyxTQUFMLENBQWVILE1BQTNDLENBQVY7SUFEQztBQURUO0FBSUZILElBQUFBLGdCQUFBLEVBQVFKLE1BQU1XLFNBQUVDLGVBQWhCLEVBQWlDLFNBQUVDLEVBQUY7V0FDL0JaLE1BQU0sQ0FBQSxHQUFJWTtBQURxQjtBQUdqQ1QsSUFBQUEsZ0JBQUEsRUFBUUosTUFBTWMsTUFBS0MsUUFBbkIsRUFBNkJKLFNBQUVDLGVBQS9CLEVBQWdELFNBQUVJLE9BQUYsRUFBV0gsRUFBWDtXQUM5Q1osTUFBTWUsU0FBU0g7QUFEK0I7QUFHaERaLFFBQVEsU0FBRWUsT0FBRixFQUFXSCxFQUFYO0lBQ1IsSUFBQUksT0FBQUMsR0FBQUMsT0FBQUMsTUFBQUM7SUFBRSxJQUFHUixHQUFHUyxNQUFILEtBQWEsR0FBaEI7UUFDRSxJQUFHTixRQUFRZCxLQUFSLEtBQWlCLE1BQXBCO1lBQ0VxQixRQUFRQyxHQUFSLENBQVk7O1FBQ2QsT0FBTyxlQUFFQyxDQUFGO1lBQVMsTUFBTUMsUUFBUUMsT0FBUjttQkFBb0JGO1FBQW5DOztJQUVUUCxJQUFJTCxFQUFFLENBQUUsRUFBRjtJQUNOTSxRQUFRUyxpQkFBSyxDQUFDQyxJQUFOLENBQVdsQixTQUFFbUIsTUFBRixDQUFTakI7SUFDNUJRLFFBQVFVLGlCQUFLLENBQUNGLElBQU47SUFDUlQsT0FBVUosUUFBUWQsS0FBUixLQUFpQixPQUFVQSxRQUFXOEIsT0FBTVosSUFBQTtJQUN0REgsUUFBUWdCLGlCQUFLLENBQUNKLElBQU4sQ0FBV1YsT0FBT0UsT0FBT0Q7V0FFakNjLFVBQUdDLEtBQUgsQ0FBU2pCLEVBQUVJLE1BQVgsRUFBbUIsZUFBQSxHQUFFZixJQUFGO1FBQ2pCLE1BQU1VLE1BQU1tQixNQUFOLElBQWE3QjtRQUNuQixNQUFBLEtBQUE7WUFDRUksU0FBRTBCLEtBQUYsQ0FBUWhCO1lBQ1IsSUFBd0JBLE1BQU1pQixNQUE5QixFQUFBO2dCQUFBLE9BQU9qQixNQUFNa0IsT0FBQTs7WUFDYixNQUFNdEIsTUFBTW1CLE1BQU47UUFIUjtJQUZpQjtBQVpiO0FBb0JSakMsV0FBV1EsU0FBRVIsUUFBRixDQUFXO0FBRXRCRCxRQUFRLGVBQUVpQixLQUFGLEVBQVNFLEtBQVQsRUFBQSxHQUFnQm1CLFVBQWhCO0lBQ1IsSUFBQUMsTUFBQXBDLE1BQUFxQztJQUFFQSxTQUFTVixPQUFNVyxXQUFOLENBQWtCeEIsT0FBT0U7SUFDbENoQixPQUFPTSxTQUFFaUMsVUFBRixDQUFhRjtJQUNwQixJQUFnQnZDLFNBQVNrQixRQUF6QjtRQUFBLE9BQU9BOztJQUVQb0IsT0FBTyxNQUFNVCxPQUFNYSxTQUFOLENBQWdCSCxRQUFRckIsT0FBT21CO0lBQzVDLElBQWdCckMsU0FBU2tCLFFBQXpCO1FBQUEsT0FBT0E7O0lBRVBFLFFBQVFDLEdBQVIsQ0FBWSxDQUFBLHVCQUFBLEVBQTJCbkIsS0FBM0IsQ0FBWixFQUFnRGdCLE1BQU1rQixPQUF0RDtJQUNBLElBQUdDLFdBQVdsQixNQUFYLEdBQW9CLEdBQXZCO1FBQ0VDLFFBQVFDLEdBQVIsQ0FBWSxnQkFBYWdCOztJQUMzQixNQUFNUixPQUFNYyxHQUFOLENBQVVMLE1BQU1wQixPQUFPbUI7SUFDN0IsSUFBZ0JyQyxTQUFTa0IsUUFBekI7UUFBQSxPQUFPQTs7SUFDUEUsUUFBUUMsR0FBUixDQUFZLENBQUEsdUJBQUEsRUFBMkJuQixLQUEzQixDQUFaO0lBRUEsTUFBTTJCLE9BQU1lLElBQU4sQ0FBV04sTUFBTXBCLE9BQU9tQjtJQUM5QixJQUFnQnJDLFNBQVNrQixRQUF6QjtRQUFBLE9BQU9BOztXQUNQQTtBQWpCTSJ9